[{"title":"angular的踩坑之旅-状态管理","url":"/2018/07/09/angular-x/","content":"\n## Quick Start\n\n###ngrx三个重要组成\n\n``` bash\n状态state（json）--查--select--UI\n状态state（json）--改--reducer--action--UI\n\n状态json作用： 使用一个 JSON 记录整个应用的状态\n              把所有数据存储到这个 JSON 里\n              相同的 JSON 应该得到相同的UI\n              把 JSON 每次的改动都保存下来，\u000b就可以方便地实现撤消重做功能\nreducer作用:  JSON不能让外部直接修改，必须封起来\n              只有 reducer 可以修改JSON\n              ACTION 相当于命令行，UI发生变化，然后命令 reducer 修改 JSON\nselector:     JSON也不能让外部直接读取，必须封起来\n              Selector 从 JSON 过滤出指定的数据，并监听其数据的变化\n              UI 使用 Selector 显示 JSON 内的数据，并在数据变化时实时更新UI\n\n```\n### 关联\n``` bash\n查询 JSON 的接口称为 **selector**（选择器），修改 JSON 的接口称为 **action**（动作），对 JSON 做出修改的程序称为 **reducer**（不知道中文怎么译，感觉怎么译都不合适。\n\n**selector** 从 JSON 过滤出某个特定的数据，并返回一个 Observable 对象（RxJS），使得当 JSON 有所改变时，界面组件（Angular 的 Component）可以马上作出响应（观察者式）。\n```\n###计算例子\n``` typescript\n// 把 JSON 中 json.count 绑定到 count 中\nexport interface AppState {\n   count: number;\n }\nexport const count = (state: AppState) => state.count;\n\n//action实际上只是一系列 const 定义。\nexport const INCREMENT = '[count]increment';\nexport const DECREMENT = '[count]decrement';\nexport const RESET = '[count]reset';\n//接下来，只要定义 **reducer** 当接收到这个指令之后如何对 JSON 操作，就完成了一个指令。\nconst initialState = {\n  count: 0\n};\n//reducer是一个纯函数，相当于action和state的中间人，需要通过他，选择什么动作action，才会有什么表现。\nexport function counterReducer(state:number  = initialState.count, action: Action) {\n  switch (action.type) {\n    case INCREMENT:\n      console.log('state.count', state);\n      return state + 1;\n    case DECREMENT:\n      return state - 1;\n    case RESET:\n      return 0;\n    default:\n      return state;\n  }\n}\n//上述代码里reducer接受两个参数，第一个参数是当前的 JSON，也就是初始化的状态，第二个参数是指令 action。其中 action 不仅仅是一个字符串，而是一个特定格式的对象\naction = {\n  type: COUNT,\n  payload: {\n    name: 1\n  }\n}\n```\nreducer写好之后，，把它注册到 @ngrx/store 中，即可让 reducer 生效：\n```typescript\n   StoreModule.forRoot(reducer, { metaReducers })\n//第一个reducer一般有多个，需要合成一个。\nexport const reducer: ActionReducerMap<any> = {\n  count: counterReducer\n};\n//metaReducers相当于是监控整个状态变化。一般如下定义，常用于打印，撤销，回退状态等操作\nexport function debug(actionReducer: ActionReducer<any>): ActionReducer<any> {\n  return function(state, action) {\n    console.log('state: ', state);\n    console.log('action: ', action);\n\n    return actionReducer(state, action);\n  };\n/**\n * 集合所有的合成 Reducer\n * @type {Array<MetaReducer<any>>}\n */\nexport const metaReducers: Array<MetaReducer<any>> = [debug, historyReducer];\n```\n在component里就可以获得初始化状态，发出action\n```typescript\n//count$是一个Observable类型的，因此Html中显示需要{{count$ | async}}\n   this.count$ = this.store.select(count);\n//dispatch\n public decrement() {\n    this.store.dispatch({ type: DECREMENT });\n  }\n```\n至此一个状态共享的例子就是如此了。了解更多[ngrx/store](https://github.com/ngrx/platform/blob/master/docs/store/README.md)。\n其中可以采用[Immutable](http://facebook.github.io/immutable-js/)提升页面性能。"},{"title":"hexo搭建的博客","url":"/2018/07/09/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]