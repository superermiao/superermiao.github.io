[{"title":"angular的踩坑之旅-你应该知道angular中的变化检测机制","url":"/2018/10/31/angular-detection/","content":"\n## 快速开始\n\n### 翻译来源\n\n    本文翻译至https://blog.angularindepth.com/everything-you-need-to-know-about-change-detection-in-angular-8006c51d206f\n\n\n### 前言\n\n    如果像我一样想要全面了解Angular中的变化检测机制，你将不得不探索其源码，毕竟网上没有太多的可靠信息。\n    大多数文章都提到每个组件都有自己的变更检测器，负责检查组件，但它们不会超出这个范围，主要关注不可变的用例和变更检测策略。\n    本文为您提供了解为什么使用不可变项的用例以及更改检测策略如何影响检查所需的信息。\n    此外，您将从本文中学到的内容将使您自己能够提出各种性能优化方案。\n    本文由两部分组成。\n    第一部分是非常技术性的并且包含很多来源的链接。它详细介绍了变化检测机制在引擎下如何工作。本文内容是基于4.0.1的Angular版本。（我翻译这篇文章时，已更新到Angular7，后续 会做出对比）。\n    在Angular版本与Angular2.4.1的版本中，如何在浏览器引擎下实现变更检测机制的方式有些不同。\n    有兴趣的话，你可以在这个: \n    [stackoverflow答案](https://stackoverflow.com/questions/42643389/why-do-we-need-ngdocheck/42807309#42807309)中阅读一些关于它是如何工作的。  \n\n### 视图作为核心概念(View as a core concept)\n    在Angular官方教程中已经提到Angular应用程序是一个组件树，然而，angular在底层实现中使用view作为其更低层次的抽象。\n    视图(view)和组件(component)之间有直接的联系---一个视图(view)对应一个组件(component)，反之亦然。\n    每个视图(view)在 组件(component) 属性中都包含了与之相关联的组件类实例的引用。\n    所有操作（如属性检查和DOM更新）都在视图(view)上执行，因此,从技术上来说，angular应用是视图树更为准确，而组件可以被描述为视图的更高级概念。\n    在[这里](https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/src/linker/view_ref.ts#L31)你可以读到有关视图的描述:\n```bash\n    A View is a fundamental building block of the application UI. It is thesmallest grouping of Elements which are created and destroyed together.\n    Properties of elements in a View can change, but the structure (number andorder) of elements in a View cannot. Changing the structure of Elements canonly be done by inserting, moving or removing nested Views via aViewContainerRef. Each View can contain many View Containers.\n    (译者注： 上述引用翻译视图是应用程序 UI 的基本构件。视图是最小的元素组，这些元素被一起创建和销毁。视图中元素的属性会改变， 但是视图中元素的结构(数量和排序)却不会改变。 要更改元素的结构，只能通过使用 ViewContainerRef 进行插入、移动或者删除嵌套视图来完成。每个视图可以包含很多视图容器。)\n```\n    本文中，我将要交替使用 ‘组件视图’ 和 ‘组件’两个概念。\n```bash\n    It’s important to note here that all articles on the web and answers on StackOverflow regarding change detection refer to the View I’m describing here as Change Detector Object or ChangeDetectorRef. In reality, there’s no separate object for change detection and View is what change detection runs on.\n    (译者注：这里需要注意的是: 网上变更检测相关的所有文章以及 StackOverflow 上的回答都把我在这里描述的视图(View)作为变更（脏值）检测器对象 或 ChangeDetectorRef。事实上并没有单独的对象来进行变更检测，变更检测就是在视图上运行。)\n```\n    每个视图可以通过[nodes](https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/src/view/types.ts#L316)属性链接子视图，因此可以对子视图执行操作。\n\n### 视图状态(View state)\n\n    每个视图都有一个状态，它扮演着非常重要的角色，因为根据它的值，Angular决定是否对视图及其所有子项运行或跳过变更（脏值）检测。状态的值可能有很多个，但以下是与本文相关的：\n    1.FirstCheck\n    2.ChecksEnabled\n    3.Errored\n    4.Destroyed\n    当ChecksEnabled是false或者视图(View)是在Errored或者Destroyed状态时，变更（脏值）检测就会跳过对于视图以及该视图所有子视图的检测。"},{"title":"angular的踩坑之旅-状态管理","url":"/2018/07/09/angular-x/","content":"\n## Quick Start\n\n###ngrx三个重要组成\n\n``` bash\n状态state（json）--查--select--UI\n状态state（json）--改--reducer--action--UI\n\n状态json作用： 使用一个 JSON 记录整个应用的状态\n              把所有数据存储到这个 JSON 里\n              相同的 JSON 应该得到相同的UI\n              把 JSON 每次的改动都保存下来，\u000b就可以方便地实现撤消重做功能\nreducer作用:  JSON不能让外部直接修改，必须封起来\n              只有 reducer 可以修改JSON\n              ACTION 相当于命令行，UI发生变化，然后命令 reducer 修改 JSON\nselector:     JSON也不能让外部直接读取，必须封起来\n              Selector 从 JSON 过滤出指定的数据，并监听其数据的变化\n              UI 使用 Selector 显示 JSON 内的数据，并在数据变化时实时更新UI\n\n```\n### 关联\n``` bash\n查询 JSON 的接口称为 **selector**（选择器），修改 JSON 的接口称为 **action**（动作），对 JSON 做出修改的程序称为 **reducer**（不知道中文怎么译，感觉怎么译都不合适。\n\n**selector** 从 JSON 过滤出某个特定的数据，并返回一个 Observable 对象（RxJS），使得当 JSON 有所改变时，界面组件（Angular 的 Component）可以马上作出响应（观察者式）。\n```\n### 计算例子\n``` typescript\n// 把 JSON 中 json.count 绑定到 count 中\nexport interface AppState {\n   count: number;\n }\nexport const count = (state: AppState) => state.count;\n\n//action实际上只是一系列 const 定义。\nexport const INCREMENT = '[count]increment';\nexport const DECREMENT = '[count]decrement';\nexport const RESET = '[count]reset';\n//接下来，只要定义 **reducer** 当接收到这个指令之后如何对 JSON 操作，就完成了一个指令。\nconst initialState = {\n  count: 0\n};\n//reducer是一个纯函数，相当于action和state的中间人，需要通过他，选择什么动作action，才会有什么表现。\nexport function counterReducer(state:number  = initialState.count, action: Action) {\n  switch (action.type) {\n    case INCREMENT:\n      console.log('state.count', state);\n      return state + 1;\n    case DECREMENT:\n      return state - 1;\n    case RESET:\n      return 0;\n    default:\n      return state;\n  }\n}\n//上述代码里reducer接受两个参数，第一个参数是当前的 JSON，也就是初始化的状态，第二个参数是指令 action。其中 action 不仅仅是一个字符串，而是一个特定格式的对象\naction = {\n  type: COUNT,\n  payload: {\n    name: 1\n  }\n}\n```\nreducer写好之后，，把它注册到 @ngrx/store 中，即可让 reducer 生效：\n```typescript\nStoreModule.forRoot(reducer, { metaReducers })\n//第一个reducer一般有多个，需要合成一个。\nexport const reducer: ActionReducerMap<any> = {\n  count: counterReducer\n};\n//metaReducers相当于是监控整个状态变化。一般如下定义，常用于打印，撤销，回退状态等操作\nexport function debug(actionReducer: ActionReducer<any>): ActionReducer<any> {\n  return function(state, action) {\n    console.log('state: ', state);\n    console.log('action: ', action);\n\n    return actionReducer(state, action);\n};\n/**\n * 集合所有的合成 Reducer\n * @type {Array<MetaReducer<any>>}\n */\nexport const metaReducers: Array<MetaReducer<any>> = [debug, historyReducer];\n```\n在component里就可以获得初始化状态，发出action\n```typescript\n//count$是一个Observable类型的，因此Html中显示需要{{count$ | async}}\nthis.count$ = this.store.select(count);\n//dispatch\npublic decrement() {\n    this.store.dispatch({ type: DECREMENT });\n}\n```\n至此一个状态共享的例子就是如此了。了解更多[ngrx/store](https://github.com/ngrx/platform/blob/master/docs/store/README.md)。\n其中可以采用[Immutable](http://facebook.github.io/immutable-js/)提升页面性能。"},{"title":"hexo搭建的博客","url":"/2018/07/09/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]