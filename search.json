[{"title":"angular的踩坑之旅-你应该知道angular中的变化检测机制","url":"/2018/11/08/angular-change-detection/","content":"\n## 快速开始\n\n### 翻译来源\n\n本文翻译至https://blog.angularindepth.com/everything-you-need-to-know-about-change-detection-in-angular-8006c51d206f\n\n\n### 前言\n\n如果像我一样想要全面了解Angular中的变化检测机制，你将不得不探索其源码，毕竟网上没有太多的靠信息。\n大多数文章都提到每个组件都有自己的变更检测器，负责检查组件，但它们不会超出这个范围，主要关不可变的用例和变更检测策略。\n本文为您提供了解为什么使用不可变项的用例以及更改检测策略如何影响检查所需的信息。\n此外，您将从本文中学到的内容将使您自己能够提出各种性能优化方案。\n本文由两部分组成。\n第一部分是非常技术性的并且包含很多来源的链接。它详细介绍了变化检测机制在引擎下如何工作。本内容是基于4.0.1的Angular版本。（我翻译这篇文章时，已更新到Angular7，后续 会做出对比）。\n在Angular版本与Angular2.4.1的版本中，如何在浏览器引擎下实现变更检测机制的方式有些不同。\n有兴趣的话，你可以在这个: \n[stackoverflow答案](https://stackoverflow.com/questions/42643389/why-do-we-need-ngdocheck/42807309#4287309)中阅读一些关于它是如何工作的。  \n\n### 视图作为核心概念(View as a core concept)\n在Angular官方教程中已经提到Angular应用程序是一个组件树，然而，angular在底层实现中使用vie作为其更低层次的抽象。\n视图(view)和组件(component)之间有直接的联系---一个视图(view)对应一个组件(component)，之亦然。\n每个视图(view)在 组件(component) 属性中都包含了与之相关联的组件类实例的引用。\n所有操作（如属性检查和DOM更新）都在视图(view)上执行，因此,从技术上来说，angular应用是视树更为准确，而组件可以被描述为视图的更高级概念。\n在[这里](https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/src/linker/view_ref.ts#L31)你可以读到有关视图的描述:\n```bash\nA View is a fundamental building block of the application UI. It is thesmallestgrouping of Elements which are created and destroyed together.\nProperties of elements in a View can change, but the structure (number andorder) ofelements in a View cannot. Changing the structure of Elements canonly be done byinserting, moving or removing nested Views via aViewContainerRef. Each View cancontain many View Containers.\n(译者注： 上述引用翻译视图是应用程序 UI 的基本构件。视图是最小的元素组，这些元素被一起创和销毁。视图中元素的属性会改变， 但是视图中元素的结构(数量和排序)却不会改变。 要更改元素结构，只能通过使用 ViewContainerRef 进行插入、移动或者删除嵌套视图来完成。每个视图可以包很多视图容器。)\n```\n本文中，我将要交替使用 ‘组件视图’ 和 ‘组件’两个概念。\n```bash\nIt’s important to note here that all articles on the web and answers onStackOverflow regarding change detection refer to the View I’m describing here asChange Detector Object or ChangeDetectorRef. In reality, there’s no separate objectfor change detection and View is what change detection runs on.\n(译者注：这里需要注意的是: 网上变更检测相关的所有文章以及 StackOverflow 上的回答都把我在里描述的视图(View)作为变更（脏值）检测器对象 或 ChangeDetectorRef。事实上并没有单独的对来进行变更检测，变更检测就是在视图上运行。)\n```\n每个视图可以通过[nodes](https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/pckages/core/src/view/types.ts#L316)属性链接子视图，因此可以对子视图执行操作。\n### 视图状态(View state)\n\n  每个视图都有一个状态，它扮演着非常重要的角色，因为根据它的值，Angular决定是否对视图及其所子项运行或跳过变更（脏值）检测。状态的值可能有很多个，但以下是与本文相关的：\n  1.FirstCheck\n  2.ChecksEnabled\n  3.Errored\n  4.Destroyed\n  当ChecksEnabled是false或者视图(View)是在Errored或者Destroyed状态时，变更（脏值）检测就跳过对于视图以及该视图所有子视图的检测。默认所有的视图会被初始化为 ChecksEnabled, 除非使了 ChangeDetectionStrategy.OnPush。稍后将详细介绍。这些状态可以组合，譬如一个视图(View可以同时设置FirstCheck和ChecksEnabled两个状态。\n  Angular有一系列高级的概念来操纵视图。我已经在[这里](https://link.jianshu.com/t=https%3A%2F%2Fblog.angularindepthcom%2Fexploring-angular-dom-abstractions-80b3ebcfc02)写了一些，其中一个概念是[ViewRef](https://link.jianshu.com/t=https%3A%2F%2Fgithub.com%2Fangular%2Fangular%2Fblob%2F6b79ab5abec8b5a4b43d563ce65032990b3e3bc%2Fpackages%2Fcore%2Fsrc%2Fview%2Frefs.ts%23L219),它封装了[底层的组件图](https://github.com/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/pckages/core/src/view/refs.ts#L239)并且有个恰当命名的方法 [detectChanges](https://githubcom/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/srcview/refs.ts#L239) 。 当异步事件发生时， Angular 会在最顶层的 ViewRef [触发变更检测](https://githubcom/angular/angular/blob/6b79ab5abec8b5a4b43d563ce65f032990b3e3bc/packages/core/srcapplication_ref.ts#L552.) ， 对最顶层的 ViewRef 执行完变更检测后，对它的子视图执行变更测。\n  你可以使用ChangeDetectorRef在组件的构造函数中注入viewRef:\n``` typescript\n    export class AppComponent {\n    constructor(cd: ChangeDetectorRef) { ... }\n```\n可以从这个类的定义中看到：\n``` typescript\n    export declare abstract class ChangeDetectorRef {\n    abstract checkNoChanges(): void;\n    abstract detach(): void;\n    abstract detectChanges(): void;\n    abstract markForCheck(): void;\n    abstract reattach(): void;\n    }\n    export abstract class ViewRef extends ChangeDetectorRef {\n    ...\n    }\n```\n  \n### 变更（脏值）检测操作(Change detection operations)\n 负责视图变更（脏值）检测的主要逻辑存在于checkAndUpdateView函数中。其大部分功能都集中在子件视图的操作上。这个函数会被从宿主组件开始的每个组件递归调用， 意思是 当递归树展开时子组件在下次调用时成为父组件。\n 对于某一特定的视图，该函数按照如下顺序执行操作：\n 1.如果视图是第一次检测， 设置 ViewState.firstCheck 为 true 。如果之前已经检测过， 则设为  false 。\n 2.检查并更新子组件或子指令的输入属性。\n 3.更新 子视图变更检测状态(变更检测策略实现的一部分)\n 4.对嵌套视图 (embedded views) 执行变更检测 (重复列表中的步骤)\n 5.如果绑定改变， 调用 子组件的 OnChanges 生命周期钩子\n 6.调用 子组件的 OnInit 和 ngDoCheck(OnInit只会在第一次检测期间调用)\n 7.更新 子视图组件实例的 ContentChildren 查询表\n 8.调用 子组件实例的 AfterContentInit 和 AfterContentChecked 生命周期钩子(AfterContentInit 只会在第一次检测期间调用)\n 9.如果当前视图 (current view) 组件实例的属性发生改变， 为 当前视图 更新DOM插值\n 10.对子视图 执行变更检测 (重复列表中的步骤)\n 11.更新 当前视图组件实例的 ViewChildren 查询表\n 12.调用 子组件实例的 AfterViewInit 和 AfterViewChecked 生命周期钩子(AfterViewInit 只在一次检测期间调用)\n 13.更新视图检测状态为禁用 (变更检测策略实现的一部分)\n 基于上面的操作列表， 有几项需要强调:\n 1.在检查子视图之前，Angular会先触发子组件的onChanges ，即使子视图不进行脏值检测onChanges也会被触发。这一条很重要，我们将在文章的第二部分看到如何利用这些知识。\n 2.视图的DOM更新是作为(变更)脏值检测机制的一部分存在的，也就是说如果组件没有被检测，即使模中使用的组件属性发生更改，DOM也不会更新（我这里提到的DOM更新实际上是插值表达式的更新）。以，对于 <span>some {{name}}</span>这个html，DOM元素 span 会在第一次检测前就渲染完，在测期间，只有 {{name}} 会被渲染。\n 3.另外一个有趣的现象就是在变更（脏值）检测期间，子组件视图的状态也会变化。我之前提到过， 有组件视图默认会用ChecksEnabled 初始化 , 但是对于那些使用 OnPush 策略的组件来说，ChecksEnabled 在第一次检测过后会被禁用。(列表中的操作 9)。\n``` typescript\n    if (view.def.flags & ViewFlags.OnPush) {\n        view.state &= ~ViewState.ChecksEnabled;\n    }\n```\n仅当父级视图的绑定发生变化且子组件视图的脏值检测策略已使用初始化ChangeDetectionStrategy.OnPush，状态才会更新。\n这意味着在接下来的脏值检测运行期间，该组件视图及其所有子组件将会跳过该检查。有关OnPush策的文档指出，只有在组件的绑定发生变化时才会检查该组件。所以要做到这一点，必须通过设ChecksEnabled来启用检查。这就是下面的代码所做的（操作2）：\n``` typescript\n    if (compView.def.flags & ViewFlags.OnPush) {\n        compView.state |= ViewState.ChecksEnabled;\n    }\n```\n最后，当前视图的变更（脏值）检测负责启动子视图的变更（脏值）检测（操作8）。如果是视图状态ChecksEnabled，则对此视图执行更改检测。这里是相关的代码：\n``` typescript\n    viewState = view.state;\n    ...\n    case ViewAction.CheckAndUpdate:\n      if ((viewState & ViewState.ChecksEnabled) &&\n        (viewState & (ViewState.Errored | ViewState.Destroyed)) === 0) {\n        checkAndUpdateView(view);\n      }\n    }\n```\n现在你明白了： 正是视图状态控制了是否对该视图以及它的子视图进行变更检测。那么问题来了—— 们能不能控制这个状态？ 结论是可以， 而这也是本文第二部分所要讲的。\n有些生命周期钩子会在DOM更新前(3, 4, 5)调用， 而有的则会在之后(9)调用。所以, 如果你有下面组件层次： A-> B -> C, 这里是钩子调用以及绑定更新的顺序：\n``` typescript\n    A: AfterContentInit\n    A: AfterContentChecked\n    A: Update bindings\n        B: AfterContentInit\n        B: AfterContentChecked\n        B: Update bindings\n            C: AfterContentInit\n            C: AfterContentChecked\n            C: Update bindings\n            C: AfterViewInit\n            C: AfterViewChecked\n        B: AfterViewInit\n        B: AfterViewChecked\n    A: AfterViewInit\n    A: AfterViewChecked\n```\n### 探索含义\n假设我们有下面的组件树：\n![变化树](angular-change-detection/component-tree.png)\n我们知道，一个组件对应一个视图。每个视图的状态都被初始化为 ViewState.ChecksEnabled，也就意味着在组件树上的每一个组件都将运行(变更)脏值检测。\n假设我们想要禁用AComponent及其子项的脏值检测，通过设置 ViewState.ChecksEnabled为false是最简答的方式。但是直接改变状态在Angular中是底层操作，为此Angular提供了一些列公开方法。每个组件可以通过 ChangeDetectorRef标识来获取关联视图。 Angular文档定义了以下公共接口：\n``` typescript\nclass ChangeDetectorRef {\n  markForCheck() : void\n  detach() : void\n  reattach() : void\n\n  detectChanges() : void\n  checkNoChanges() : void\n}\n```\n让我们看看这可以为我们带来什么好处。\n### detach\n第一种允许我们操作状态的方法是detach，它可以简单地禁用对当前视图的脏值检测：\n``` typescript\ndetach(): void { this._view.state &= ~ViewState.ChecksEnabled; }\n```\n让我们看看它在代码中的应用：\n``` typescript\nexport class AComponent {\n  constructor(public cd: ChangeDetectorRef) {\n    this.cd.detach();\n  }\n```\n这确保了在接下来的变更检测中，从 AComponent 开始的左边分支会被跳过(橘黄色的组件不会被检测)\n![detach](angular-change-detection/detach-accomponent.png)\n这里有两点需要注意—— 第一点就是虽然我们更改了 AComponent 的状态， 它的所有子组件同样不会被检查。 第二点是因为左边分支的组件没有进行变更检测， 在这些组件模板中的DOM 同样不会被更新。 这里有个小例子演示：\n``` typescript\n@Component({\n  selector: 'a-comp',\n  template: `<span>See if I change: {{changed}}</span>`\n})\nexport class AComponent {\n  constructor(public cd: ChangeDetectorRef) {\n    this.changed = 'false';\n\n    setTimeout(() => {\n      this.cd.detach();\n      this.changed = 'true';\n    }, 2000);\n  }\n```\n组件第一次被检查的时候， span 会用文本 See if I change: false渲染。 2 秒后， 当属性changed更新为 true , span 中的文本并没有改变。 然而， 如果我们移除这行 this.cd.detech() 一切如常。\n### reattach\n正如文章第一部分所述，如果输入属性发生变化，OnChanges就会被触发。这意味着一旦我们得知输入属性变化，我们就可以激活当前组件的检测器来运行脏值检测，并在下一轮关闭它。举个例子：\n``` typescript\nexport class AComponent {\n  @Input() inputAProp;\n\n  constructor(public cd: ChangeDetectorRef) {\n    this.cd.detach();\n  }\n\n  ngOnChanges(values) {\n    this.cd.reattach();\n    setTimeout(() => {\n      this.cd.detach();\n    })\n  }\n```\nreattach通过位运算简单的设置了 ViewState.ChecksEnabled\n``` typescript\nreattach(): void { this._view.state |= ViewState.ChecksEnabled; }\n```\n这几乎等同于把ChangeDetectionStrategy设置为OnPush：在第一次更改检测运行后禁用检查，在父组件绑定属性变化时启用它，并在运行后禁用。\n\n请注意，OnChanges仅在禁用分支中最顶层的组件中触发，而不是在禁用的分支中的每个组件触发。\n### markForCheck\nreattach方法仅作用于当前组件，对父级组件则不起作用。这意味着该reattach方法仅适用于禁用分支中最顶层的组件。\n我们需要一种启用从当前组件到根组件检测的方法，markForCheck应用而生：\n``` typescript\nlet currView: ViewData|null = view;\nwhile (currView) {\n  if (currView.def.flags & ViewFlags.OnPush) {\n    currView.state |= ViewState.ChecksEnabled;\n  }\n  currView = currView.viewContainerParent || currView.parent;\n}\n```\n从源码的实现中我们可以看到，markForCheck向上逐层遍历并启用检测。\n\n这什么时候有用？ 就像 ngOnChanges 一样，即使组件使用 OnPush 策略，ngDoCheck生命周期钩子也会被触发。再次强调， 它只会在禁止检测分支的顶级组件上触发， 而不是禁止检测分支的所有组件。但是， 我们可以使用这个钩子进行自定义逻辑并把我们的组件标记为合乎变更检测周期运行条件。 由于 Angular 只会检查 对象引用， 我们可以实现对某些对象属性的脏检查：\n``` typescript\nComponent({\n   ...,\n   changeDetection: ChangeDetectionStrategy.OnPush\n})\nMyComponent {\n   @Input() items;\n   prevLength;\n   constructor(cd: ChangeDetectorRef) {}\n\n   ngOnInit() {\n      this.prevLength = this.items.length;\n   }\n\n   ngDoCheck() {\n      if (this.items.length !== this.prevLength) {\n         this.cd.markForCheck(); \n         this.prevLenght = this.items.length;\n      }\n   }\n```\n### detectChanges\n使用detectChanges可以为当前组件及其所有子项运行一次脏值检测。此方法会忽略视图的状态，这意味着当前视图可能依旧保持禁用状态，并且不会对组件进行常规脏值检测。举个例子：\n``` typescript\nexport class AComponent {\n  @Input() inputAProp;\n\n  constructor(public cd: ChangeDetectorRef) {\n    this.cd.detach();\n  }\n\n  ngOnChanges(values) {\n    this.cd.detectChanges();\n  }\n```\n即使脏值检测器依旧是detached，输入属性更改时DOM也会更新。\n### checkNoChanges\n脏值检测的最后一个可用方法是确保在当前检测运行过程中不会有变化发生。基本上，它执行了列表中1,7,8操作，如果它发现了需要变更的绑定或者会引发DOM的更新，它都会抛出异常。\n译者注：\n1.脏值检测的底层实现在Angualr不同版本有些不同，本文第一部分基于Angular4.0.1，如果想了解Angular2.4.1的实现机制，请移步[stackoverflow](https://blog.angularindepth.com/everything-you-need-to-know-about-change-detection-in-angular-8006c51d206f)"},{"title":"angular的踩坑之旅-状态管理","url":"/2018/07/09/angular-x/","content":"\n## Quick Start\n\n###ngrx三个重要组成\n\n``` bash\n状态state（json）--查--select--UI\n状态state（json）--改--reducer--action--UI\n\n状态json作用： 使用一个 JSON 记录整个应用的状态\n              把所有数据存储到这个 JSON 里\n              相同的 JSON 应该得到相同的UI\n              把 JSON 每次的改动都保存下来，\u000b就可以方便地实现撤消重做功能\nreducer作用:  JSON不能让外部直接修改，必须封起来\n              只有 reducer 可以修改JSON\n              ACTION 相当于命令行，UI发生变化，然后命令 reducer 修改 JSON\nselector:     JSON也不能让外部直接读取，必须封起来\n              Selector 从 JSON 过滤出指定的数据，并监听其数据的变化\n              UI 使用 Selector 显示 JSON 内的数据，并在数据变化时实时更新UI\n\n```\n### 关联\n``` bash\n查询 JSON 的接口称为 **selector**（选择器），修改 JSON 的接口称为 **action**（动作），对 JSON 做出修改的程序称为 **reducer**（不知道中文怎么译，感觉怎么译都不合适。\n\n**selector** 从 JSON 过滤出某个特定的数据，并返回一个 Observable 对象（RxJS），使得当 JSON 有所改变时，界面组件（Angular 的 Component）可以马上作出响应（观察者式）。\n```\n### 计算例子\n``` typescript\n// 把 JSON 中 json.count 绑定到 count 中\nexport interface AppState {\n   count: number;\n }\nexport const count = (state: AppState) => state.count;\n\n//action实际上只是一系列 const 定义。\nexport const INCREMENT = '[count]increment';\nexport const DECREMENT = '[count]decrement';\nexport const RESET = '[count]reset';\n//接下来，只要定义 **reducer** 当接收到这个指令之后如何对 JSON 操作，就完成了一个指令。\nconst initialState = {\n  count: 0\n};\n//reducer是一个纯函数，相当于action和state的中间人，需要通过他，选择什么动作action，才会有什么表现。\nexport function counterReducer(state:number  = initialState.count, action: Action) {\n  switch (action.type) {\n    case INCREMENT:\n      console.log('state.count', state);\n      return state + 1;\n    case DECREMENT:\n      return state - 1;\n    case RESET:\n      return 0;\n    default:\n      return state;\n  }\n}\n//上述代码里reducer接受两个参数，第一个参数是当前的 JSON，也就是初始化的状态，第二个参数是指令 action。其中 action 不仅仅是一个字符串，而是一个特定格式的对象\naction = {\n  type: COUNT,\n  payload: {\n    name: 1\n  }\n}\n```\nreducer写好之后，，把它注册到 @ngrx/store 中，即可让 reducer 生效：\n```typescript\nStoreModule.forRoot(reducer, { metaReducers })\n//第一个reducer一般有多个，需要合成一个。\nexport const reducer: ActionReducerMap<any> = {\n  count: counterReducer\n};\n//metaReducers相当于是监控整个状态变化。一般如下定义，常用于打印，撤销，回退状态等操作\nexport function debug(actionReducer: ActionReducer<any>): ActionReducer<any> {\n  return function(state, action) {\n    console.log('state: ', state);\n    console.log('action: ', action);\n\n    return actionReducer(state, action);\n};\n/**\n * 集合所有的合成 Reducer\n * @type {Array<MetaReducer<any>>}\n */\nexport const metaReducers: Array<MetaReducer<any>> = [debug, historyReducer];\n```\n在component里就可以获得初始化状态，发出action\n```typescript\n//count$是一个Observable类型的，因此Html中显示需要{{count$ | async}}\nthis.count$ = this.store.select(count);\n//dispatch\npublic decrement() {\n    this.store.dispatch({ type: DECREMENT });\n}\n```\n至此一个状态共享的例子就是如此了。了解更多[ngrx/store](https://github.com/ngrx/platform/blob/master/docs/store/README.md)。\n其中可以采用[Immutable](http://facebook.github.io/immutable-js/)提升页面性能。"},{"title":"hexo搭建的博客","url":"/2018/07/09/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]